// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{GUEST_CODE_FOR_ZK_PROOF_ELF, GUEST_CODE_FOR_ZK_PROOF_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::Deserialize;

#[derive(Deserialize)]
struct CompactLog {
    v: u32,
    events: Vec<String>,
}

#[derive(serde::Serialize)]
struct ValidateLogInput {
    events: Vec<i128>,
}

#[derive(serde::Deserialize)]
struct ValidateLogOutput {
    fair: bool,
    reason: Option<String>,
    left_score: u32,
    right_score: u32,
    events_len: u32,
    log_hash_sha256: [u8; 32],
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Load the compact log JSON (argument required)
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: pong-prover <path-to-pong-log.json>");
        eprintln!("Example: pong-prover pong-log_seed930397884_events49_1757552715309.json");
        std::process::exit(1);
    }

    let path = &args[1];

    // Check file size before reading (DoS protection)
    const MAX_LOG_SIZE: u64 = 10 * 1024 * 1024; // 10 MB
    let metadata = std::fs::metadata(path).unwrap_or_else(|e| {
        eprintln!("Error accessing file '{}': {}", path, e);
        std::process::exit(1);
    });

    if metadata.len() > MAX_LOG_SIZE {
        eprintln!("Log file too large: {} bytes (max {} bytes)", metadata.len(), MAX_LOG_SIZE);
        eprintln!("This may indicate a malformed or malicious file");
        std::process::exit(1);
    }

    let raw = std::fs::read_to_string(path).unwrap_or_else(|e| {
        eprintln!("Error reading file '{}': {}", path, e);
        std::process::exit(1);
    });

    let log: CompactLog = serde_json::from_str(&raw).unwrap_or_else(|e| {
        eprintln!("Error parsing JSON: {}", e);
        std::process::exit(1);
    });

    if log.v != 1 {
        eprintln!("Unsupported log version: {}", log.v);
        std::process::exit(1);
    }

    // Convert events to i128 fixed-point integers from decimal strings
    let mut events: Vec<i128> = Vec::with_capacity(log.events.len());
    for s in log.events.iter() {
        let v: i128 = s.parse().unwrap_or_else(|e| {
            eprintln!("Error parsing event '{}': {}", s, e);
            std::process::exit(1);
        });
        events.push(v);
    }

    eprintln!("Loaded {} events from {}", events.len(), path);
    eprintln!("Generating proof...");

    let input = ValidateLogInput { events };

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();
    let prove_info = prover.prove(env, GUEST_CODE_FOR_ZK_PROOF_ELF).unwrap_or_else(|e| {
        eprintln!("Proof generation failed: {}", e);
        std::process::exit(1);
    });
    let receipt = prove_info.receipt;

    eprintln!("Verifying proof...");
    receipt.verify(GUEST_CODE_FOR_ZK_PROOF_ID).unwrap_or_else(|e| {
        eprintln!("Proof verification failed: {}", e);
        std::process::exit(1);
    });

    let out: ValidateLogOutput = receipt.journal.decode().unwrap();

    if !out.fair {
        eprintln!("\nProof verified successfully!");
        eprintln!("Result: UNFAIR GAME");
        eprintln!("Reason: {}", out.reason.unwrap_or_else(|| "Unknown".to_string()));
        eprintln!("Log Hash: 0x{}", hex::encode(out.log_hash_sha256));
        println!("UNFAIR");
        std::process::exit(1);
    } else {
        eprintln!("\nProof verified successfully!");
        eprintln!("Result: FAIR GAME");
        eprintln!("Log Hash: 0x{}", hex::encode(out.log_hash_sha256));
        eprintln!("Events Processed: {}", out.events_len);
        println!("{}-{}", out.left_score, out.right_score);
    }
}
