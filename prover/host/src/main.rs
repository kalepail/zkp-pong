// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{GUEST_CODE_FOR_ZK_PROOF_ELF, GUEST_CODE_FOR_ZK_PROOF_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::Deserialize;

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
struct GameConfig {
    seed: u32,
    width: i32,
    height: i32,
    paddle_height: i32,
    paddle_width: i32,
    paddle_margin: i32,
    ball_radius: i32,
    paddle_max_speed: i32,
    serve_speed: i32,
    speed_increment: i32,
    max_bounce_angle_deg: i32,
    serve_max_angle_deg: i32,
    points_to_win: u32,
    micro_jitter_milli_deg: i32,
    ai_offset_max_permille: i32,
}

#[derive(Deserialize)]
struct CompactLog {
    v: u32,
    config: GameConfig,
    events: Vec<String>,
}

#[derive(serde::Serialize)]
struct ConfigInts {
    seed: u32,
    width: i32,
    height: i32,
    paddle_height: i32,
    paddle_width: i32,
    paddle_margin: i32,
    ball_radius: i32,
    paddle_max_speed: i32,
    serve_speed: i32,
    speed_increment: i32,
    max_bounce_angle_deg: i32,
    serve_max_angle_deg: i32,
    points_to_win: u32,
    micro_jitter_milli_deg: i32,
    ai_offset_max_permille: i32,
}

#[derive(serde::Serialize)]
struct ValidateLogInput {
    config: ConfigInts,
    events: Vec<i128>,
}

#[derive(serde::Deserialize)]
struct ValidateLogOutput {
    fair: bool,
    reason: Option<String>,
    left_score: u32,
    right_score: u32,
    events_len: u32,
    log_hash_sha256: [u8; 32],
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Load the compact log JSON (argument required)
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: pong-prover <path-to-pong-log.json>");
        eprintln!("Example: pong-prover pong-log_seed930397884_events49_1757552715309.json");
        std::process::exit(1);
    }

    let path = &args[1];
    let raw = std::fs::read_to_string(path).unwrap_or_else(|e| {
        eprintln!("Error reading file '{}': {}", path, e);
        std::process::exit(1);
    });

    let log: CompactLog = serde_json::from_str(&raw).unwrap_or_else(|e| {
        eprintln!("Error parsing JSON: {}", e);
        std::process::exit(1);
    });

    if log.v != 1 {
        eprintln!("Unsupported log version: {}", log.v);
        std::process::exit(1);
    }

    let cfg = &log.config;
    let cfg_ints = ConfigInts {
        seed: cfg.seed,
        width: cfg.width,
        height: cfg.height,
        paddle_height: cfg.paddle_height,
        paddle_width: cfg.paddle_width,
        paddle_margin: cfg.paddle_margin,
        ball_radius: cfg.ball_radius,
        paddle_max_speed: cfg.paddle_max_speed,
        serve_speed: cfg.serve_speed,
        speed_increment: cfg.speed_increment,
        max_bounce_angle_deg: cfg.max_bounce_angle_deg,
        serve_max_angle_deg: cfg.serve_max_angle_deg,
        points_to_win: cfg.points_to_win,
        micro_jitter_milli_deg: cfg.micro_jitter_milli_deg,
        ai_offset_max_permille: cfg.ai_offset_max_permille,
    };

    // Convert events to i128 fixed-point integers from decimal strings
    let mut events: Vec<i128> = Vec::with_capacity(log.events.len());
    for s in log.events.iter() {
        let v: i128 = s.parse().unwrap_or_else(|e| {
            eprintln!("Error parsing event '{}': {}", s, e);
            std::process::exit(1);
        });
        events.push(v);
    }

    eprintln!("Loaded {} events from {}", events.len(), path);
    eprintln!("Generating proof...");

    let input = ValidateLogInput { config: cfg_ints, events };

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();
    let prove_info = prover.prove(env, GUEST_CODE_FOR_ZK_PROOF_ELF).unwrap_or_else(|e| {
        eprintln!("Proof generation failed: {}", e);
        std::process::exit(1);
    });
    let receipt = prove_info.receipt;

    eprintln!("Verifying proof...");
    receipt.verify(GUEST_CODE_FOR_ZK_PROOF_ID).unwrap_or_else(|e| {
        eprintln!("Proof verification failed: {}", e);
        std::process::exit(1);
    });

    let out: ValidateLogOutput = receipt.journal.decode().unwrap();

    if !out.fair {
        eprintln!("\nProof verified successfully!");
        eprintln!("Result: UNFAIR GAME");
        eprintln!("Reason: {}", out.reason.unwrap_or_else(|| "Unknown".to_string()));
        eprintln!("Log Hash: 0x{}", hex::encode(out.log_hash_sha256));
        println!("UNFAIR");
        std::process::exit(1);
    } else {
        eprintln!("\nProof verified successfully!");
        eprintln!("Result: FAIR GAME");
        eprintln!("Log Hash: 0x{}", hex::encode(out.log_hash_sha256));
        eprintln!("Events Processed: {}", out.events_len);
        println!("{}-{}", out.left_score, out.right_score);
    }
}
