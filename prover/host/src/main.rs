// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use core::{CompactLog, ValidateLogInput, ValidateLogOutput};
use methods::{GUEST_CODE_FOR_ZK_PROOF_ELF, GUEST_CODE_FOR_ZK_PROOF_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Load the compact log JSON (argument required)
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: pong-prover <path-to-pong-log.json>");
        eprintln!("Example: pong-prover pong-log_seed930397884_events49_1757552715309.json");
        std::process::exit(1);
    }

    let path = &args[1];

    // Check file size before reading (DoS protection)
    const MAX_LOG_SIZE: u64 = 10 * 1024 * 1024; // 10 MB
    let metadata = std::fs::metadata(path).unwrap_or_else(|e| {
        eprintln!("Error accessing file '{}': {}", path, e);
        std::process::exit(1);
    });

    if metadata.len() > MAX_LOG_SIZE {
        eprintln!("Log file too large: {} bytes (max {} bytes)", metadata.len(), MAX_LOG_SIZE);
        eprintln!("This may indicate a malformed or malicious file");
        std::process::exit(1);
    }

    let raw = std::fs::read_to_string(path).unwrap_or_else(|e| {
        eprintln!("Error reading file '{}': {}", path, e);
        std::process::exit(1);
    });

    let log: CompactLog = serde_json::from_str(&raw).unwrap_or_else(|e| {
        eprintln!("Error parsing JSON: {}", e);
        std::process::exit(1);
    });

    if log.v != 1 {
        eprintln!("Unsupported log version: {}", log.v);
        std::process::exit(1);
    }

    // Parse events directly as Q16.16 (i64)
    // Frontend now generates Q16.16 format directly, so no conversion needed
    let mut events: Vec<i64> = Vec::with_capacity(log.events.len());
    for s in log.events.iter() {
        let v_q16: i64 = s.parse().unwrap_or_else(|e| {
            eprintln!("Error parsing event '{}': {}", s, e);
            std::process::exit(1);
        });
        events.push(v_q16);
    }

    eprintln!("Loaded {} events from {}", events.len(), path);
    eprintln!("Generating proof...");

    let input = ValidateLogInput { events };

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();
    let prove_info = prover.prove(env, GUEST_CODE_FOR_ZK_PROOF_ELF).unwrap_or_else(|e| {
        eprintln!("Proof generation failed: {}", e);
        std::process::exit(1);
    });
    let receipt = prove_info.receipt;

    eprintln!("Verifying proof...");
    receipt.verify(GUEST_CODE_FOR_ZK_PROOF_ID).unwrap_or_else(|e| {
        eprintln!("Proof verification failed: {}", e);
        std::process::exit(1);
    });

    let out: ValidateLogOutput = receipt.journal.decode().unwrap();

    if !out.fair {
        eprintln!("\nProof verified successfully!");
        eprintln!("Result: UNFAIR GAME");
        eprintln!("Reason: {}", out.reason.unwrap_or_else(|| "Unknown".to_string()));
        eprintln!("Log Hash: 0x{}", hex::encode(out.log_hash_sha256));
        println!("UNFAIR");
        std::process::exit(1);
    } else {
        eprintln!("\nProof verified successfully!");
        eprintln!("Result: FAIR GAME");
        eprintln!("Log Hash: 0x{}", hex::encode(out.log_hash_sha256));
        eprintln!("Events Processed: {}", out.events_len);
        println!("{}-{}", out.left_score, out.right_score);
    }
}
