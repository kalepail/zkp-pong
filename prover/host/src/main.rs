// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{GUEST_CODE_FOR_ZK_PROOF_ELF, GUEST_CODE_FOR_ZK_PROOF_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::Deserialize;

#[derive(Deserialize)]
struct GameConfig {
    seed: u32,
    width: i32,
    height: i32,
    paddleHeight: i32,
    paddleWidth: i32,
    paddleMargin: i32,
    ballRadius: i32,
    paddleMaxSpeed: i32,
    serveSpeed: i32,
    speedIncrement: i32,
    maxBounceAngleDeg: i32,
    serveMaxAngleDeg: i32,
    pointsToWin: u32,
    microJitterMilliDeg: i32,
    aiOffsetMaxPermille: i32,
}

#[derive(Deserialize)]
struct CompactLog {
    v: u32,
    config: GameConfig,
    events: Vec<String>,
}

#[derive(serde::Serialize)]
struct ConfigInts {
    seed: u32,
    width: i32,
    height: i32,
    paddle_height: i32,
    paddle_width: i32,
    paddle_margin: i32,
    ball_radius: i32,
    paddle_max_speed: i32,
    serve_speed: i32,
    speed_increment: i32,
    max_bounce_angle_deg: i32,
    serve_max_angle_deg: i32,
    points_to_win: u32,
    micro_jitter_milli_deg: i32,
    ai_offset_max_permille: i32,
}

#[derive(serde::Serialize)]
struct ValidateLogInput {
    config: ConfigInts,
    events: Vec<i128>,
}

#[derive(serde::Deserialize)]
struct ValidateLogOutput {
    fair: bool,
    reason: Option<String>,
    left_score: u32,
    right_score: u32,
    events_len: u32,
    log_hash_sha256: [u8; 32],
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // A default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // Load the compact log JSON (default file if no arg)
    let args: Vec<String> = std::env::args().collect();
    let path = if args.len() > 1 { &args[1] } else { "../pong-log_seed930397884_events49_1757552715309.json" };
    let raw = std::fs::read_to_string(path).expect("read log");
    let log: CompactLog = serde_json::from_str(&raw).expect("parse log");
    assert_eq!(log.v, 1, "log version");

    let cfg = &log.config;
    let cfg_ints = ConfigInts {
        seed: cfg.seed,
        width: cfg.width,
        height: cfg.height,
        paddle_height: cfg.paddleHeight,
        paddle_width: cfg.paddleWidth,
        paddle_margin: cfg.paddleMargin,
        ball_radius: cfg.ballRadius,
        paddle_max_speed: cfg.paddleMaxSpeed,
        serve_speed: cfg.serveSpeed,
        speed_increment: cfg.speedIncrement,
        max_bounce_angle_deg: cfg.maxBounceAngleDeg,
        serve_max_angle_deg: cfg.serveMaxAngleDeg,
        points_to_win: cfg.pointsToWin,
        micro_jitter_milli_deg: cfg.microJitterMilliDeg,
        ai_offset_max_permille: cfg.aiOffsetMaxPermille,
    };

    // Convert events to i128 fixed-point integers from decimal strings
    let mut events: Vec<i128> = Vec::with_capacity(log.events.len());
    for s in log.events.iter() {
        let v: i128 = s.parse().expect("event int parse");
        events.push(v);
    }
    eprintln!("Loaded events: {}", events.len());
    let input = ValidateLogInput { config: cfg_ints, events };

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();
    let prove_info = prover.prove(env, GUEST_CODE_FOR_ZK_PROOF_ELF).unwrap();
    let receipt = prove_info.receipt;

    let out: ValidateLogOutput = receipt.journal.decode().unwrap();
    if !out.fair {
        println!(
            "VALIDATED fair=false reason={} left={} right={} events={} hash=0x{}",
            out.reason.unwrap_or_default(),
            out.left_score,
            out.right_score,
            out.events_len,
            hex::encode(out.log_hash_sha256)
        );
    } else {
        println!(
            "VALIDATED fair=true left={} right={} events={} hash=0x{}",
            out.left_score,
            out.right_score,
            out.events_len,
            hex::encode(out.log_hash_sha256)
        );
    }

    receipt.verify(GUEST_CODE_FOR_ZK_PROOF_ID).unwrap();
}
