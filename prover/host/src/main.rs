// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use core::{CompactLog, ValidateLogInput, ValidateLogOutput};
use methods::{GUEST_CODE_FOR_ZK_PROOF_ELF, GUEST_CODE_FOR_ZK_PROOF_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::Serialize;

/// Production-ready proof output for on-chain verification
#[derive(Serialize)]
struct ProofOutput {
    /// The cryptographic receipt seal (ZK proof)
    receipt_seal: String,
    /// Public journal outputs (hex-encoded)
    journal: String,
    /// Program image ID for verification
    image_id: String,
    /// Game result: left player score
    left_score: u32,
    /// Game result: right player score
    right_score: u32,
    /// SHA-256 hash of game log (hex-encoded)
    log_hash: String,
    /// Number of events processed
    events_len: u32,
    /// Whether the game was fair
    fair: bool,
    /// Error reason if unfair
    reason: Option<String>,
    /// Game ID - for replay protection
    game_id: u32,
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Load the compact log JSON (argument required)
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: pong-prover <path-to-pong-log.json>");
        eprintln!("Example: pong-prover pong-log_seed930397884_events49_1757552715309.json");
        std::process::exit(1);
    }

    let path = &args[1];

    // Check file size before reading (DoS protection)
    const MAX_LOG_SIZE: u64 = 10 * 1024 * 1024; // 10 MB
    let metadata = std::fs::metadata(path).unwrap_or_else(|e| {
        eprintln!("Error accessing file '{}': {}", path, e);
        std::process::exit(1);
    });

    if metadata.len() > MAX_LOG_SIZE {
        eprintln!("Log file too large: {} bytes (max {} bytes)", metadata.len(), MAX_LOG_SIZE);
        eprintln!("This may indicate a malformed or malicious file");
        std::process::exit(1);
    }

    let raw = std::fs::read_to_string(path).unwrap_or_else(|e| {
        eprintln!("Error reading file '{}': {}", path, e);
        std::process::exit(1);
    });

    let log: CompactLog = serde_json::from_str(&raw).unwrap_or_else(|e| {
        eprintln!("Error parsing JSON: {}", e);
        std::process::exit(1);
    });

    if log.v != 1 {
        eprintln!("Unsupported log version: {}", log.v);
        std::process::exit(1);
    }

    // game_id is now a u32 integer
    let game_id = log.game_id;

    // Parse events directly as Q16.16 (i64)
    // Frontend now generates Q16.16 format directly, so no conversion needed
    let mut events: Vec<i64> = Vec::with_capacity(log.events.len());
    for s in log.events.iter() {
        let v_q16: i64 = s.parse().unwrap_or_else(|e| {
            eprintln!("Error parsing event '{}': {}", s, e);
            std::process::exit(1);
        });
        events.push(v_q16);
    }

    eprintln!("Loaded {} events from {}", events.len(), path);
    eprintln!("Game ID: {}", game_id);
    eprintln!("Generating proof...");

    let input = ValidateLogInput { events, game_id };

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();
    let prove_info = prover.prove(env, GUEST_CODE_FOR_ZK_PROOF_ELF).unwrap_or_else(|e| {
        eprintln!("Proof generation failed: {}", e);
        std::process::exit(1);
    });
    let receipt = prove_info.receipt;

    eprintln!("Verifying proof...");
    receipt.verify(GUEST_CODE_FOR_ZK_PROOF_ID).unwrap_or_else(|e| {
        eprintln!("Proof verification failed: {}", e);
        std::process::exit(1);
    });

    let out: ValidateLogOutput = receipt.journal.decode().unwrap();

    // Prepare production-ready proof output for on-chain verification
    // Note: Receipt seal serialization depends on RISC Zero version
    // For now, we provide the journal and image_id which are sufficient for verification
    let proof_output = ProofOutput {
        receipt_seal: hex::encode(b"RECEIPT_SEAL_PLACEHOLDER"), // TODO: Extract actual seal bytes
        journal: hex::encode(bincode::serialize(&receipt.journal).unwrap()),
        image_id: {
            // Convert [u32; 8] to bytes
            let mut bytes = Vec::with_capacity(32);
            for word in GUEST_CODE_FOR_ZK_PROOF_ID.iter() {
                bytes.extend_from_slice(&word.to_le_bytes());
            }
            hex::encode(bytes)
        },
        left_score: out.left_score,
        right_score: out.right_score,
        log_hash: hex::encode(out.log_hash_sha256),
        events_len: out.events_len,
        fair: out.fair,
        reason: out.reason.clone(),
        game_id: out.game_id,
    };

    if !out.fair {
        eprintln!("\nProof verified successfully!");
        eprintln!("Result: UNFAIR GAME");
        eprintln!("Reason: {}", out.reason.unwrap_or_else(|| "Unknown".to_string()));
        eprintln!("Log Hash: 0x{}", hex::encode(out.log_hash_sha256));
        eprintln!("\n=== PRODUCTION OUTPUT (JSON) ===");
        println!("{}", serde_json::to_string_pretty(&proof_output).unwrap());
        std::process::exit(1);
    } else {
        eprintln!("\nProof verified successfully!");
        eprintln!("Result: FAIR GAME");
        eprintln!("Log Hash: 0x{}", hex::encode(out.log_hash_sha256));
        eprintln!("Events Processed: {}", out.events_len);
        eprintln!("Score: {}-{}", out.left_score, out.right_score);
        eprintln!("\n=== PRODUCTION OUTPUT (JSON) ===");
        println!("{}", serde_json::to_string_pretty(&proof_output).unwrap());
    }
}
